import json
import json
import os
import sys
import subprocess
import shutil
from pathlib import Path

import aiofiles
from solders.keypair import Keypair
from bip_utils import Bip39SeedGenerator, Bip44, Bip44Coins, Bip44Changes
from .http import loads

# Older versions of ``solders`` do not expose ``to_bytes`` which our tests rely
# on. Provide a backwards compatible shim.
if not hasattr(Keypair, "to_bytes"):

    def _to_bytes(self) -> bytes:  # pragma: no cover - shim for old versions
        return bytes(self.to_bytes_array())

    Keypair.to_bytes = _to_bytes  # type: ignore[attr-defined]


if not hasattr(Keypair, "to_bytes_array"):

    def _to_bytes_array(self) -> list[int]:  # pragma: no cover - shim for old versions
        return list(self.to_bytes())

    Keypair.to_bytes_array = _to_bytes_array  # type: ignore[attr-defined]


KEYPAIR_DIR = os.getenv("KEYPAIR_DIR", "keypairs")
ACTIVE_KEYPAIR_FILE = os.path.join(KEYPAIR_DIR, "active")
os.makedirs(KEYPAIR_DIR, exist_ok=True)


def load_keypair(path: str) -> Keypair:
    """Load a Solana ``Keypair`` from a JSON file generated by ``solana-keygen``.

    Parameters
    ----------
    path:
        Path to the keypair JSON file. It should contain an array of integers.
    """
    with open(path, "r") as f:
        data = json.load(f)
    if not isinstance(data, list):
        raise ValueError("Invalid keypair file")
    secret = bytes(data)
    return Keypair.from_bytes(secret)


async def load_keypair_async(path: str) -> Keypair:
    """Asynchronously load a Solana ``Keypair`` from ``path``."""
    async with aiofiles.open(path, "r") as f:
        content = await f.read()
    data = loads(content)
    if not isinstance(data, list):
        raise ValueError("Invalid keypair file")
    secret = bytes(data)
    return Keypair.from_bytes(secret)


def list_keypairs() -> list[str]:
    """Return the names of all saved keypairs."""
    return [
        f[:-5]
        for f in os.listdir(KEYPAIR_DIR)
        if f.endswith(".json") and os.path.isfile(os.path.join(KEYPAIR_DIR, f))
    ]


def save_keypair(name: str, data: list[int]) -> None:
    """Persist a keypair under ``name``.

    The name must not contain path traversal components.
    """
    if (
        os.path.sep in name
        or (os.path.altsep and os.path.altsep in name)
        or ".." in name
    ):
        raise ValueError("invalid keypair name")
    path = os.path.join(KEYPAIR_DIR, name + ".json")
    with open(path, "w", encoding="utf-8") as f:
        json.dump(data, f)


def select_keypair(name: str) -> None:
    """Mark the named keypair as active."""
    path = os.path.join(KEYPAIR_DIR, name + ".json")
    if not os.path.exists(path):
        raise FileNotFoundError(path)
    with open(ACTIVE_KEYPAIR_FILE, "w", encoding="utf-8") as f:
        f.write(name)


def get_active_keypair_name() -> str | None:
    try:
        with open(ACTIVE_KEYPAIR_FILE, "r", encoding="utf-8") as f:
            return f.read().strip() or None
    except FileNotFoundError:
        return None


def load_selected_keypair() -> Keypair | None:
    name = get_active_keypair_name()
    if not name:
        return None
    path = os.path.join(KEYPAIR_DIR, name + ".json")
    return load_keypair(path)


async def load_selected_keypair_async() -> Keypair | None:
    name = get_active_keypair_name()
    if not name:
        return None
    path = os.path.join(KEYPAIR_DIR, name + ".json")
    return await load_keypair_async(path)


def load_keypair_from_mnemonic(mnemonic: str, passphrase: str = "") -> Keypair:
    """Derive a Solana ``Keypair`` from a BIP-39 mnemonic.

    The key is derived from the standard path ``m/44'/501'/0'/0'`` which matches
    the behavior of ``solana-keygen recover``.

    Parameters
    ----------
    mnemonic:
        Space separated seed words.
    passphrase:
        Optional passphrase for the seed.
    """

    seed = Bip39SeedGenerator(mnemonic).Generate(passphrase)
    secret = (
        Bip44.FromSeed(seed, Bip44Coins.SOLANA)
        .Purpose()
        .Coin()
        .Account(0)
        .Change(Bip44Changes.CHAIN_EXT)
        .AddressIndex(0)
        .PrivateKey()
        .Raw()
        .ToBytes()
    )
    return Keypair.from_seed(secret)


def ensure_default_keypair() -> None:
    """Create and select a default keypair if none is active."""

    active_file = Path(ACTIVE_KEYPAIR_FILE)
    if active_file.exists():
        return

    setup_script = Path(__file__).resolve().parent.parent / "scripts" / "setup_default_keypair.sh"
    try:
        result = subprocess.run(
            ["bash", str(setup_script)], capture_output=True, text=True, check=True
        )
    except (OSError, subprocess.CalledProcessError) as exc:
        print(f"Failed to run {setup_script}: {exc}")
        raise SystemExit(1)

    mnemonic = result.stdout.strip()
    if mnemonic:
        print(f"Generated mnemonic: {mnemonic}")
        print("Please store this mnemonic securely; it will not be shown again.")


def ensure_keypair() -> None:
    try:
        from bip_utils import Bip39MnemonicGenerator
    except Exception:  # pragma: no cover - bip_utils optional
        Bip39MnemonicGenerator = None  # type: ignore[assignment]

    def _wallet_cmd(*args: str) -> list[str]:
        if shutil.which("solhunter-wallet") is not None:
            return ["solhunter-wallet", *args]
        return [sys.executable, "-m", "solhunter_zero.wallet_cli", *args]

    keypairs = list_keypairs()
    active = get_active_keypair_name()
    if keypairs:
        if len(keypairs) == 1 and active is None:
            name = keypairs[0]
            select_keypair(name)
            print(f"Automatically selected keypair '{name}'.")
        return

    mnemonic = os.environ.get("MNEMONIC")
    keypair_json = os.environ.get("KEYPAIR_JSON")
    if not mnemonic and not keypair_json:
        if Bip39MnemonicGenerator is None:
            kp = Keypair()
            save_keypair("default", list(kp.to_bytes()))
            select_keypair("default")
            print("Automatically generated keypair 'default' and selected it.")
            return
        mnemonic = str(Bip39MnemonicGenerator().FromWordsNumber(24))
        passphrase = os.environ.get("PASSPHRASE", "")
        subprocess.check_call(
            _wallet_cmd("derive", "default", mnemonic, "--passphrase", passphrase)
        )
        subprocess.check_call(_wallet_cmd("select", "default"))
        os.environ.setdefault("MNEMONIC", mnemonic)
        name = get_active_keypair_name() or "default"
        print(f"Generated mnemonic: {mnemonic}")
        print("Please store this mnemonic securely; it will not be shown again.")
        print(f"Automatically generated keypair '{name}' and selected it.")
        return

    print("No keypairs found in 'keypairs/' directory.")
    if keypair_json:
        subprocess.check_call(_wallet_cmd("save", "default", keypair_json))
        subprocess.check_call(_wallet_cmd("select", "default"))
        print("Keypair saved from KEYPAIR_JSON and selected as 'default'.")
        return

    if mnemonic:
        passphrase = os.environ.get("PASSPHRASE", "")
        subprocess.check_call(
            _wallet_cmd("derive", "default", mnemonic, "--passphrase", passphrase)
        )
        subprocess.check_call(_wallet_cmd("select", "default"))
        print("Keypair saved from MNEMONIC and selected as 'default'.")
        return
