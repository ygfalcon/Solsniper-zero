import json
from .http import loads
import os
import aiofiles
from solders.keypair import Keypair
from bip_utils import Bip39SeedGenerator, Bip44, Bip44Coins, Bip44Changes

# Older versions of ``solders`` do not expose ``to_bytes`` which our tests rely
# on. Provide a backwards compatible shim.
if not hasattr(Keypair, "to_bytes"):

    def _to_bytes(self) -> bytes:  # pragma: no cover - shim for old versions
        return bytes(self.to_bytes_array())

    Keypair.to_bytes = _to_bytes  # type: ignore[attr-defined]


if not hasattr(Keypair, "to_bytes_array"):

    def _to_bytes_array(self) -> list[int]:  # pragma: no cover - shim for old versions
        return list(self.to_bytes())

    Keypair.to_bytes_array = _to_bytes_array  # type: ignore[attr-defined]


KEYPAIR_DIR = os.getenv("KEYPAIR_DIR", "keypairs")
ACTIVE_KEYPAIR_FILE = os.path.join(KEYPAIR_DIR, "active")
os.makedirs(KEYPAIR_DIR, exist_ok=True)


def load_keypair(path: str) -> Keypair:
    """Load a Solana ``Keypair`` from a JSON file generated by ``solana-keygen``.

    Parameters
    ----------
    path:
        Path to the keypair JSON file. It should contain an array of integers.
    """
    with open(path, "r") as f:
        data = json.load(f)
    if not isinstance(data, list):
        raise ValueError("Invalid keypair file")
    secret = bytes(data)
    return Keypair.from_bytes(secret)


async def load_keypair_async(path: str) -> Keypair:
    """Asynchronously load a Solana ``Keypair`` from ``path``."""
    async with aiofiles.open(path, "r") as f:
        content = await f.read()
    data = loads(content)
    if not isinstance(data, list):
        raise ValueError("Invalid keypair file")
    secret = bytes(data)
    return Keypair.from_bytes(secret)


def list_keypairs() -> list[str]:
    """Return the names of all saved keypairs."""
    return [
        f[:-5]
        for f in os.listdir(KEYPAIR_DIR)
        if f.endswith(".json") and os.path.isfile(os.path.join(KEYPAIR_DIR, f))
    ]


def save_keypair(name: str, data: list[int]) -> None:
    """Persist a keypair under ``name``.

    The name must not contain path traversal components.
    """
    if (
        os.path.sep in name
        or (os.path.altsep and os.path.altsep in name)
        or ".." in name
    ):
        raise ValueError("invalid keypair name")
    path = os.path.join(KEYPAIR_DIR, name + ".json")
    with open(path, "w", encoding="utf-8") as f:
        json.dump(data, f)


def select_keypair(name: str) -> None:
    """Mark the named keypair as active."""
    path = os.path.join(KEYPAIR_DIR, name + ".json")
    if not os.path.exists(path):
        raise FileNotFoundError(path)
    with open(ACTIVE_KEYPAIR_FILE, "w", encoding="utf-8") as f:
        f.write(name)


def get_active_keypair_name() -> str | None:
    try:
        with open(ACTIVE_KEYPAIR_FILE, "r", encoding="utf-8") as f:
            return f.read().strip() or None
    except FileNotFoundError:
        return None


def load_selected_keypair() -> Keypair | None:
    name = get_active_keypair_name()
    if not name:
        return None
    path = os.path.join(KEYPAIR_DIR, name + ".json")
    return load_keypair(path)


async def load_selected_keypair_async() -> Keypair | None:
    name = get_active_keypair_name()
    if not name:
        return None
    path = os.path.join(KEYPAIR_DIR, name + ".json")
    return await load_keypair_async(path)


def load_keypair_from_mnemonic(mnemonic: str, passphrase: str = "") -> Keypair:
    """Derive a Solana ``Keypair`` from a BIP-39 mnemonic.

    The key is derived from the standard path ``m/44'/501'/0'/0'`` which matches
    the behavior of ``solana-keygen recover``.

    Parameters
    ----------
    mnemonic:
        Space separated seed words.
    passphrase:
        Optional passphrase for the seed.
    """

    seed = Bip39SeedGenerator(mnemonic).Generate(passphrase)
    secret = (
        Bip44.FromSeed(seed, Bip44Coins.SOLANA)
        .Purpose()
        .Coin()
        .Account(0)
        .Change(Bip44Changes.CHAIN_EXT)
        .AddressIndex(0)
        .PrivateKey()
        .Raw()
        .ToBytes()
    )
    return Keypair.from_seed(secret)
